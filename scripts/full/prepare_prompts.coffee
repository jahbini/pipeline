#!/usr/bin/env coffee
###
prepare_prompts.coffee — memo-pure version (2025)

Generates a prompt-formatting policy from:
  • contract JSON loaded from memo
  • dataset samples loaded from memo
Writes:
  • prompt policy JSON → memo key (params.prompt_policy)

NEVER reads/writes the filesystem.
All I/O is via @memo.

###

@step =
  desc: "Generate prompt-formatting policy JSON (memo-native)"

  action: (M, stepName) ->
    params = (M.theLowdown "params/#{stepName}.json").value

    # Required step keys
    for k in ['contract','prompt_policy','template_name','stop_strings','use_eos_token']
      throw new Error "Missing step #{stepName}.#{k}" unless params[k]?

    CONTRACT_KEY     = params.contract
    POLICY_KEY       = params.prompt_policy
    TEMPLATE_NAME    = params.template_name
    STOP_STRINGS     = params.stop_strings
    USE_EOS_TOKEN    = params.use_eos_token

    log = (msg) ->
      stamp = new Date().toISOString().replace('T',' ').replace('Z','')
      line = "[#{stamp}] #{msg}"
      console.log stepName, line
      try M.logThis?(stepName, line) catch e then null

    # ------------------------------------------------------------
    # Load contract from memo
    # ------------------------------------------------------------
    contractEntry = M.theLowdown(CONTRACT_KEY)
    contract = contractEntry.value || await contractEntry.notifier
    throw new Error "Missing contract in memo: #{CONTRACT_KEY}" unless contractEntry?
    throw new Error "Contract is empty or malformed" unless contract.filenames?

    # Determine text field heuristically
    textField = 'text'
    if contract.schema?.fields?
      for k,v of contract.schema.fields
        if String(v).toLowerCase() is 'string'
          textField = k

    # ------------------------------------------------------------
    # Extract first N samples from train split (memo-pure)
    # ------------------------------------------------------------
    N = 3
    samples = []
    if contract.filenames.train?
      trainKey = "data/" + contract.filenames.train.chosen

      trainEntry = M.theLowdown(trainKey)
      if trainEntry?.value?
        lines = trainEntry.value
        for line in lines when samples.length < N
          try
            obj = JSON.parse(line)
            if typeof obj[textField] is 'string'
              samples.push obj[textField]
          catch e
            continue

    log "Collected #{samples.length} sample texts from memo (#{textField})"

    # ------------------------------------------------------------
    # Formatting templates
    # ------------------------------------------------------------
    fmtPlain = (text) -> text

    fmtIclMinimal = (text) ->
      "### Instruction\nShare an important thought.\n\n### Response\n" + text.trim()

    fmtLlama3Style = (text) ->
      "<s>[INSTRUCTION]\nShare an important thought.\n[/INSTRUCTION]\n" +
      "[RESPONSE]\n" + text.trim() + "\n[/RESPONSE]</s>"

    FORMATTERS =
      plain_text_passthrough: fmtPlain
      icl_minimal: fmtIclMinimal
      llama3_style: fmtLlama3Style

    unless FORMATTERS[TEMPLATE_NAME]?
      throw new Error "Unknown formatter TEMPLATE_NAME: #{TEMPLATE_NAME}"

    formatter = FORMATTERS[TEMPLATE_NAME]

    # ------------------------------------------------------------
    # Build policy object
    # ------------------------------------------------------------
    preview = []
    for i in [0...Math.min(2, samples.length)]
      preview.push
        before: samples[i]
        after: formatter(samples[i])

    policy =
      template_name: TEMPLATE_NAME
      text_field: textField
      stop_strings: STOP_STRINGS
      use_eos_token: USE_EOS_TOKEN
      preview: preview
      notes: [
        "Generated by prepare_prompts.coffee (memo-native)",
        "This policy describes how prompts should be formatted during fine-tuning."
      ]

    # ------------------------------------------------------------
    # Save to memo
    # ------------------------------------------------------------
    M.saveThis POLICY_KEY, policy
    M.saveThis "prepare_prompts:policy", policy

    log "Wrote prompt policy into memo key #{POLICY_KEY}"
    log "Completed successfully."
    return
